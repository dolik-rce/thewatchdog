#include "Server.h"
#include <plugin/zip/zip.h>

SKYLARK(Config, "config") {
	//TODO: this code is largely duplicate of Auth method...
	String nonce = AsString(Uuid::Create());
	SQLR * Select(ID,NAME,SALT).From(CLIENT).Where(ID == 0);
	ValueMap clients;
	String salts;
	ValueMap vm;
	while(SQLR.Fetch(vm)){
		salts.Cat() << vm["ID"] << ':' << vm["SALT"] << '|';
		clients.Add(IntStr(vm["ID"])+";"+String(vm["SALT"]),vm["NAME"]);
	}
	String id = http[".__identity__"];
	if(id.IsEmpty()) {
		id = AsString(Uuid::Create());
		http.SessionSet("__identity__", id);
	}
	
	String target="import";
	
	Time t = GetSysTime();
	
	SQL * Insert(AUTH)(NONCE, nonce)(VALID, t);
	http("WD_ID", id)
	    ("WD_NONCE", nonce)
	    ("CLIENTS", clients)
	    ("TARGET", target)
	    ("IMPORT", http["import"])
	    ("FILENAME", Format("wd_%d-%02d-%02d_%02d:%02d.zip",t.year,t.month,t.day,t.hour,t.minute));

	http.RenderResult("templates/config");
}

String SqlEscape(const Value& in){
	if(in.IsNull() && !in.Is<String>() && !in.Is<WString>()) {
		return "NULL";
	}
	if(in.Is<int>() || in.Is<int64>() || in.Is<double>())
		return in.ToString();
	if(in.Is<Time>() || in.Is<Date>())
		return "\'" + in.ToString() + "\'";
	
	String str = in.ToString();
	const char* s = str.Begin();
	const char* lim = str.End();
	String t;
	t.Cat('\'');
	while(s < lim) {
		switch(*s) {
		case '\a': t.Cat("\\a"); break;
		case '\b': t.Cat("\\b"); break;
		case '\f': t.Cat("\\f"); break;
		case '\t': t.Cat("\\t"); break;
		case '\v': t.Cat("\\v"); break;
		case '\r': t.Cat("\\r"); break;
		case '\'': t.Cat("''"); break;
		case '\\': t.Cat("\\\\"); break;
		case '\n': t.Cat("\\n"); break;
		default:
			if(byte(*s) < 32 || (byte)*s >= 0x7f) {
				char h[4];
				int q = (byte)*s;
				h[0] = '\\';
				h[1] = (3 & (q >> 6)) + '0';
				h[2] = (7 & (q >> 3)) + '0';
				h[3] = (7 & q) + '0';
				t.Cat(h, 4);
			}
			else {
				t.Cat(*s);
			}
			break;
		}
		s++;
	}
	t.Cat('\'');
	return t;
}

String ExportTable(const SqlId& table, const SqlSet& columns) {
	StringStream data;
	
	data << ~columns << "\n";
	
	SQL * Select(columns)
	        .From(table);
	
	Vector<Value> row;
	while(SQL.Fetch(row)) {
		for(int i = 0; i < row.GetCount(); i++){
			if(i)
				data << '\t';
			data << SqlEscape(row[i]);
		}
		data << '\n';
	}
	return data.GetResult();
}

SKYLARK(Export, "export:POST") {
	if(!CheckAuth2(http, SQL, 0, "/export"))
		return;
	
	SetDateFormat("%1:4d/%2:02d/%3:02d");
	
	StringZip zip;
	
	zip.WriteFolder("schema", GetSysTime());
	zip.WriteFolder("data", GetSysTime());
	
	const int* dialects = DynamicSqlSession::SupportedDialects();
	for(int j = 0; dialects[j]; j++){
		String dir = "schema/" + DynamicSqlSession::DialectToString(dialects[j]);
		SqlSchema sch;
		All_Tables(sch, dialects[j]);
		for(int i = SqlSchema::SCHEMA; i <= SqlSchema::DROPCONFIG; i++)
			zip.WriteFile(sch.Script(i), sch.NormalFileName(i,dir));
	}
	
	#define EXPORT_TABLE(T) zip.WriteFile(ExportTable(T, SqliteSchema::S_##T::ColumnSet()), "data/" #T ".tsv")
	
	EXPORT_TABLE(SESSION);
	EXPORT_TABLE(CLIENT);
	EXPORT_TABLE(AUTH);
	EXPORT_TABLE(WORK);
	EXPORT_TABLE(RESULT);
	EXPORT_TABLE(MAIL);
	
	#undef EXPORT_TABLE
	
	// TODO: pack also output files
	
	String fn=http["filename"];
	if(fn.IsEmpty())
		fn = "watchdog.zip";
	
	http.SetHeader("Content-Disposition", "attachment; filename="+fn);
	http.Content("text/plain", zip.Finish());
}

SKYLARK(Import, "import:POST") {
	if(!CheckAuth2(http, SQL, 0, "/import"))
		return;
	
	//we must finish the previous session, otherwise block table would fail
	SQL.Commit();
	SQL.Begin();
	
	VectorMap<String, String> scripts;
	String schdir = "schema/" + DynamicSqlSession::DialectToString(SQL.GetDialect()) + "/";
	
	StringUnZip unzip(http["import"]);
	
	while(!(unzip.IsEof() || unzip.IsError())) {
		if(unzip.IsFolder()) {
			unzip.SkipFile();
			continue;
		}
		String path = unzip.GetPath();
		if(path.StartsWith(schdir)) {
			scripts.Add(path.Mid(schdir.GetCount()), unzip.ReadFile());
			continue;
		}
		unzip.SkipFile();
	}
	
	SqlPerformScript(scripts[SqlSchema::DROPSCHEMA]);
	SqlPerformScript(scripts[SqlSchema::SCHEMA]);
	
	unzip.Create(http["import"]);
	while(!(unzip.IsEof() || unzip.IsError())) {
		if(unzip.IsFolder()) {
			unzip.SkipFile();
			continue;
		}
		String path = unzip.GetPath();
		if(path.StartsWith("data/")) {
			StringStream s(unzip.ReadFile());
			StringStream data;
			String table = path.Mid(5, path.GetCount() - 9);
			String columns = s.GetLine();
			while (!(s.IsEof() || s.IsError())){
				Vector<String> line = Split(s.GetLine(), "\t", false);
				data << "insert into \"" << table << "\" (" << columns
				     << ") values (";
				for(int i = 0; i < line.GetCount(); i++){
					if (i)
						data << ",";
					data << line[i];
				}
				data << ");\n";
			}
			RLOG("Loading data into " << table);
			SqlPerformScript(data.GetResult());
			continue;
		}
		unzip.SkipFile();
	}
	
	SqlPerformScript(scripts[SqlSchema::ATTRIBUTES]);
	SqlPerformScript(scripts[SqlSchema::CONFIG]);
	
	// TODO: unpack also output files
	
	http.Redirect("/config?import=1");
}
